(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{459:function(e,t,o){"use strict";o.r(t),t.default=[{title:"call、apply、bind區別以及手寫",path:"/posts/JS%E5%9F%BA%E7%A4%8E/call%E3%80%81apply%E3%80%81bind%E5%8D%80%E5%88%A5%E4%BB%A5%E5%8F%8A%E6%89%8B%E5%AF%AB.html",strippedContent:' ## call、apply、bind 區別  `call`、`apply` 這兩個方法可以調用函數並且修改 `this` 值，方便我們同一個函數傳遞不同的物件上下文達到復用。  - call - 第一個參數為 `this` 值，後續參數則為要當作函數的參數。 - apply - 第一個參數一樣為 `this` 值，而第二個參數為陣列，一樣為當作函數的參數。  至於 `bind` 也能夠綁定 `this` 值，但是並不會調用函數，而是將函數返回。  ## 手寫 call  我們可以先思考一下要怎麼改變一個函數的 `this` 值。  ```js function fn() {   console.log(this.msg); }  let obj = {   msg: "objMsg", };  fn.call(obj); // objMsg ```  首先，我們將 `fn` 添加到 `obj` 中，即可獲得他的 `this` 值，接著在呼叫在 `obj` 裡的 `fn` 後再刪除即可以完成。 不過要注意幾個點:  1. 如果 `this` 參數傳的是一個非真值的物件時，則直接回傳 `window` 2. 臨時的 `key` 不能夠覆蓋到原先的物件上的值，所以用唯一值 `symbol`就很好解決這件事。 3. 要如何獲得調用的函數呢? 其實我們 `Call` 函數的 `this` 值就是指向該調用的函數 (`fn.call`)。 4. 我們需要將呼叫的函數回傳值返回  ```js Function.prototype.Call = function (target, ...args) {   target = target || window;   let key = Symbol();   target[key] = this;   const res = target[key](...args);   delete target[key];   return res; }; ```  邏輯清楚後，實現 `call` 是很簡單的。  ## 手寫 apply  `apply` 與 `call` 差別只有在傳參的不同，`call` 源碼中，我們只要改變傳餐的方法即可實現。  ```js Function.prototype.Apply = function (target, argsArr) {   target = target || window;   let key = Symbol();   target[key] = this;   let res = target[key](...argsArr);   delete target[key];   return res; }; ```  ## bind  首先可以看一下 [bind](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind) 的定義以及傳了什麼參數。  接著我們可以依照上面的理解，來實作 `bind` 源碼。   透過上面文章，我們能夠知道 `bind` 除了傳入要修改的 `this`值 當作第一個參數，還包含要傳入到函數的參數。  ```js Function.prototype.Bind = function (target, ...args) {   target = target || {};   let key = Symbol();   target[key] = this;   return function (...innerArgs) {     return target[key](...args, ...innerArgs);   }; }; ```  由於 `bind` 也可以傳入預設參數但是返回的函數也能夠傳入參數，所以我們需要將兩組參數依序傳給閉包中的 `target[key]`。   至於不刪除 `target[key]` 則是因為 `bind` 後的函數是可以重複調用的。  ## 參考  - [面试官为啥总是让我们手撕 call、apply、bind](https://juejin.cn/post/7128233572380442660) '},{title:"this",path:"/posts/JS%E5%9F%BA%E7%A4%8E/this.html",strippedContent:" ## 前言  在執行上下文的詞法環境中，我們談到在創建詞法階段時會綁定 `this` 值，所以我們能夠知道 `this` 的值是在調用函數時才確認，而非創建函數時。   而該篇我們來談論 `this` 值是如何確定的。  ## this 是什麼? `this` 值是一個物件，該值是指向調用該函數的引用物件。   這樣設計是方便我們能夠用更隱式的方式傳遞引用物件，使得程式碼更加簡潔。     ## this 的綁定規則 先說自己總結的結論為，`this` 值是指向 \"最後\" 調用該函數的物件。    - 默認綁定    在全局與函數下使用 `this`，默認值是指向 `window`。   ```js   console.log(this)   function hello(){     console.log(this) // this   }   hello() // 可以看作 window.hello()   ```    不過當開啟嚴格模式(`use strict`)時， 函數中的 `this` 值將會為 `undefined`。       ```js   function hello(){     'use strict'     console.log(this) // undefined   }   hello()   ```    多層嵌套的函數中，由於 `c` 函數並未有物件調用，所以默認指向 `window`。     ```js   var msg = 'global' // 如果使用 let, const 來定義變數，變數並不會添加到 window 上   function a(){     function b(){       var msg = 'bMsg'       function c(){         console.log(this.msg) // global       }       c()     }     b()   }   a()   ``` - 隱式綁定    透過物件調用的函數，則屬於隱式綁定的一種。     ```js   var msg = 'global'   function fn(){     console.log(this.msg)   }   let obj = {     msg:'objMsg',     func:fn   }      fn() // global   obj.func() // objMsg   ```    不過需要注意可能會有 `this` 丟失物件的問題。     下方例子，`newFn` 賦值 `obj.func`，初學者可能會認為 `this` 值應該為 `obj`，可是實際調用後會發現 `this` 值變為 `window`。     按照我們最一開始的結論來看，實際上是 `window` 調用 `newFn` 函數。      ```js   var msg = 'global'   function fn(){     console.log(this.msg)   }   let obj = {     msg:'objMsg',     func:fn   }    var newFn = obj.func    fn() // global   obj.func() // objMsg   newFn() // global   ``` - 顯式綁定   我們可以透過 `call`、`apply`、`bind` 來綁定函數內的 `this` 值。    簡單說明一下 `call`、`apply`、`bind` 區別  - call - 可以改變函數內 `this` 值，第一個參數為要改變 `this` 值的物件，剩餘參數則用逗號隔開，為綁定的函數參數。    - apply - 與 `call` 相同，只有傳入函數參數的格式不同，為陣列。    - bind - 僅綁定 `this` 值而不會執行該函數。      ```js  var obj1 = {   msg:'obj1Msg'  }   var obj2 = {   msg:'obj2Msg'  }    var msg = 'globalMsg'   function fn(){   console.log(this.msg)  }    fn() // globalMsg  fn.call(obj1)  //obj1Msg  fn.apply(obj2) //obj2Msg  var newFn = fn.bind(obj1)  newFn() //obj2Msg   ```   有一些內置函數的餐數其實也提供綁定 `this` 值。    ex: `forEach`  ```js  let obj = {   extraNumber:10  }    const newData = [1,2,3].map(function(number){    return number + this.extraNumber  },obj)   console.log(newData) // [11,12,13]  ```  - new 綁定  使用 `new` 呼叫構造函數時，`new` 內部會將 `new` 中創建的新物件賦值給 `this`。   其實我們了解 `new` 主要做了哪些事情，就很容易明白 `this` 值怎麼被賦值了。   主要有四個步驟：    1. 創建新的物件。    2. 讓新物件連結構造函數的原型鏈，使新物件能夠訪問構造函數的原型鏈。    3. 呼叫構造函數並將新物件當作 `this` 傳入給構造函數。    4. 若構造函數本身有返回物件則返回，若無則將新的物件返回。     ```js  function fakeNew(con,...args){     let obj = {}     Object.setPrototypeOf(obj,con.prototype) // obj.__proto__ = con.prototype     let result = con.call(obj,...args)     return typeof result === 'object' ? result : obj  }   let Person = function(name,age){   this.name = name   this.age = age  }   Person.prototype.hello = function(){   console.log(`hello, ${this.name}, your age: ${this.age}`)  }   let leo = fakeNew(Person,'leo',27)  leo.hello()  ```  - 箭頭函數 箭頭函數中是不存在 `this` 的，所以在函數中用 `this` ，其實是指向父層的 `this`。    ```js var msg = 'globalMsg'  var fn1 = () =>{   console.log(this.msg) }  function fn2(){   console.log(this.msg) }  let obj ={   msg:'objMsg',   fn1: fn1,   fn2: fn2,   fn3: () => {     console.log(this.msg)   },   fn4: function() {     var callback = () =>{       console.log(this.msg)     }     callback()   } } obj.fn1() // globalMsg obj.fn2() // objMsg obj.fn3() // globalMsg obj.fn4() // objMsg  ```  順帶一提，使用箭頭函數時無法當做構造函數。   根據我們上面分析的 `new` 原理，其中有一條是鏈結構造函數原型鏈以及呼叫構造函數並將新物件當作 `this` 傳入。   但是在箭頭函數中是沒有 `this` 以及原型鏈的，所以無法使用 `new`，也就無法當做構造函數。       ## this 的優先級 有時候可能會應用到多條規則，那麼必須清楚知道其先後順序。   先說結論， `new` > `顯示綁定` > `隱式綁定` > `默認綁定`， 接著我們分析是為什麼？    1. 默認綁定與隱式綁定很容易理解，`this` 終究指向最後調用該函數的物件。  ```js var msg = 'globalMsg'  function fn(){   console.log(this.msg) }  let obj = {   msg:'objMsg',   fn:fn }  obj.fn() // objMsg  ```  2. 隱式綁定與顯式綁定  ```js  function fn(){   console.log(this.msg) }   let obj = {   msg:'objMsg',   fn:fn }   let obj2 = {   msg:'obj2Msg',   fn:fn }  obj.fn() // objMsg obj.fn.call(obj2) // obj2Msg ```  我們會發現用顯式綁定的話，原本隱式綁定的 `msg=objMsg` 變成輸出了 `msg=obj2Msg`，證明了顯式綁定比隱式綁定優先級還高。  3. `new` 與顯式綁定   ```js function fn(){   console.log(this.msg) }   let obj = {   msg:'objMsg',   fn:fn }  let bindFn = fn.bind(obj) bindFn() // 'objMsg' let newFn = new bindFn() // undefined ```  先用 `bind` 做顯式綁定，在用 `new` 將顯示綁定的函數當作構造函數，會發現我們之前顯示綁定的值被替代掉了，變成 `undefined`。    ## 參考 - [你小子,又在偷偷学this指向](https://juejin.cn/post/7162747517350707213) - [ES6 系列之箭头函数](https://github.com/mqyqingfeng/Blog/issues/85) - 你不知道的JS"},{title:"閉包",path:"/posts/JS%E5%9F%BA%E7%A4%8E/%E9%96%89%E5%8C%85.html",strippedContent:' ## 閉包  函數在可訪問的作用域之外的地方被調用就會形成閉包。  用一個貼近生活的例子來說明閉包：  ```js function school() {   let schoolmaster = "陳校長";    return function securityGuard() {     function lier() {       schoolmaster = "許校長";     }      function info() {       console.log(schoolmaster);     }      return {       lier,       info,     };   }; } let getSecurityGuard1 = school(); getSecurityGuard1().lier(); getSecurityGuard1().info(); //許校長  let getSecurityGuard2 = school(); getSecurityGuard2().info(); //陳校長 ```  想像到了一個完全沒去過的學校，不曉得校長叫什麼名字。所幸校園裡有提供一個方法讓我們找保全去詢問。   第一個保全說叫許校長，第二個保全說叫陳校長，當然在現實中我們肯定知道有人在說謊，也還是不曉得校長到底叫什麼...  不過依照上面的經歷中，我們已經體驗了閉包。我們始終無法真正的訪問到 `schoolmaster`確定校長真正的名字，但是我們擁有訪問它以及修改該值的能力。   這也就是我們一開始所說的函數在可訪問的作用域之外的地方被調用就會形成閉包。  ## 閉包的原理  暸解作用域與執行上下文後，我們很容易理解閉包是怎麼生成的。   函數創建時，作用域就已經確認了。而當我們執行一個函數時，執行上下文會被創建，確認了 `this`、作用域鏈、詞法環境並且推入執行棧。  依照上面的例子，我們創建一個變數 `getSecurityGuard1`，將調用 `school` 返回的 `securityGuard` 函數賦值給 `getSecurityGuard1`，此時 `getSecurityGuard1` 可以調用 `securityGuard` 函數。   此時的執行上下文與執行棧的變化為:  1. 創建全局上下文，並且將全局上下文推入棧。 2. 執行 `school`時，創建其上下文，並且推入棧。 3. 返回 `securityGuard` 函數，`school` 出棧。 4. 將 `securityGuard` 函數賦值給 `getSecurityGuard1` 。  接著在全局作用域底下調用 `getSecurityGuard1` 函數，函數中又返回 `lier`、`info` 方法，接著依序執行`lier`、`info`。  1. 創建 `securityGuard` 執行上下文，並且推入棧。 2. 將 `securityGuard` 推出棧，並返回 `lier`、`info` 方法。 3. 創建 `lier` 執行上下文，並且推入棧。 4. 修改 `schoolmaster` 的值，不過該值並沒有在 `lier` 作用域中，所以必須往上查找作用域鏈，到`school` 層的時候發現 `schoolmaster` 值，將值變為 `許校長`。 5. `info` 與 `lier` 邏輯大致相同就不說明了。  上面我們在全局作用域中透過 `getSecurityGuard1` 去調用原本訪問不到的 `securityGuard` 函數，因此我們也擁有了 `securityGuard` 的作用域。  ## 閉包的用處  我認為閉包主要的應用場景在於需要維護私有變數的情況下。  例如我們在作用域文章中所提及到的計數器程式碼:  ```js function counter() {   let count = 0;   function add() {     count++;     console.log(count);   }   return {     add,   }; } let countController = counter(); countController.add(); // 1 countController.add(); // 2 ```  在上面程式碼中，`count` 既不會放到全局上導致變數污染，並且可以保存或修改變數的值。  ## 閉包的應用  多虧了閉包，我們可以保存、修改私有變數的值，以下是常見的場景。  - 單例模式    保證一個類別只有一個實例。實現方法是判斷實例是否存在，若存在則直接返回，否則創建了再返回。     好處是避免了重複實例化帶來的記憶體開銷。    ```js   function Hello() {     this.msg = "hello";   }    Hello.instance = (function () {     var instance;     return function () {       if (!instance) {         instance = new Hello();       }       return instance;     };   })();    const sayHello = Hello.instance();   const sayHello1 = Hello.instance();   console.log(sayHello === sayHello1); // true   console.log(sayHello.msg); // hello   ```    我們使用一個匿名函數來實作一個閉包，`instance` 變數用來儲存實例，返回函數來提供我們從外部作用域中調用。     當調用 `Hello.instance` 的函數時，我們可以對 `instance` 變數進行修改或查詢。  - 柯里化    一種高階函數，可以將接受多個參數的函數變成接受單一參數。     能夠避免重複定義相同的函數，而達到復用效果。    例如我們想創建一個對某人打招呼的方法，根據不同語言而返回不同問候語。    ```js   function hello(greeting) {     return function (name) {       console.log(`${greeting}, ${name}!`);     };   }   let chinese = hello("你好");   chinese("陳同學");   chinese("王同學");    let english = hello("hello");   english("leo");   english("decadeHew");   ```    透過柯里化我們就不用每次都需要傳入多筆且重複的參數。  ## 記憶體洩漏  由於閉包保存了本來已經要被垃圾收回的變數，記憶體無法被釋放，可能會導致應用卡頓或者崩潰。   所以建議還是不要過度使用閉包，若要使用的話，記得不需要該閉包時，需要進行釋放。   釋放方式也很簡單，只要將使用到閉包的變數設為`null` 即可。  ## 參考  [閉包](https://juejin.cn/post/6844904165672484871#heading-9) '},{title:"執行上下文與執行棧",path:"/posts/JS%E5%9F%BA%E7%A4%8E/%E5%9F%B7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E8%88%87%E5%9F%B7%E8%A1%8C%E6%A3%A7.html",strippedContent:" ## 執行上下文  代碼執行時的環境，根據呼叫的方式不同可能會產生不同的結果。  ```js function hello(name){   console.log('hello,' name) }  hello('leo')  // hello,leo hello('evan') // hello,evan ```  呼叫相同函數，但是 `arguments` 傳遞不同值，會產生不同結果，這些是在執行該函數時才會確認下來。  ## 執行上下文種類  - 全局執行上下文 - 只有一種。當代碼一執行時即會創建，直到程式結束為止( 例如關閉網頁瀏覽器 ) - 函數執行上下文 - 每次執行函數時都會創建一次上下文。    `eval` 也能創建執行上下文，但是使用 `eval` 可能會引發更多問題，所以不在本文探討內。  ## 執行上下文的生命週期  - 創建階段    即函數被調用時，但未執行任何代碼之前。     此時會做幾件事：    - 確認 this 值   - 詞法環境 (LexicalEnvironment)      分為全局環境與函數環境:      ```js     GlobalExectionContext = { // 全局執行上下文       LexicalEnviroment:{ // 詞法環境         EnvironmentRecord:{ // 環境紀錄           Type: 'Ojbect'           outer: <null> // 對外部環境的引用         }       }     }      FunctionExectionContext = { // 函數執行上下文       LexicalEnviroment:{ // 詞法環境         EnvironmentRecord:{ // 環境紀錄           Type: 'Declarative' // 函數環境           outer: <Global or outer function environment reference> // 對外部環境的引用         }       }     }     ```      - 全局環境:        是一個沒有外部引用的詞法環境。這很好理解，因為已經是最上層的執行環境了。         擁有 `window` 物件與一些關聯的方法，例如瀏覽器的方法。也可能包含使用者自行定義的全局變數。         `this` 值也指向 `window` 這個全局物件。      - 函數環境:        使用者定義的變數被儲存至環境紀錄中，包含了`arguments` 物件。         而外部環境的引用可能是全局環境，也可以是包含該函數的外部函數。        ```js       function hello(myName) {         let name = myName;         function sayHi() {           console.log(\"hello\", name);         }         sayHi(name);       }       hello(\"leo\"); // hello,leo       ```      - 環境紀錄:        儲存變數與函數聲明的位置。      - 外部環境的引用:        指向父層的作用域進行連接，這也是作用域鏈發生在執行上下文的原因。    - 變數環境 (VariableEnvironment)      也是詞法環境的一種，差別在於 `ES6` 中，詞法環境用於儲存函數聲明與`let` 、`const` 宣告的變數綁定。 而變數環境只用於儲存 `var` 宣告的變數。       因此變數環境實現函數級作用域，而通過詞法環境在函數作用域的基礎上實現塊級作用域。      而在詞法環境中的 `let` 與 `const` 會保持未初始化 `uninitialized` 而 `var` 會被定義為 `undefined`。       依照上面的了解，就很好解釋 `var` 變數提升的問題。    - 建立作用域鏈      在詞法環境的外部環境引用中發生。個人覺得很重要，所以額外列出來幫助記憶。  - 執行階段    對變數進行賦值，並執行代碼。  - 銷毀階段    執行完畢後，會從執行棧出棧，並且等待回收。  ## 執行棧  執行棧是儲存執行程式碼時創建的執行上下文，採用先進後出的方式進行維護。   由於 `javascript` 是單線程，每次只能做一件事情，所以通過這種機制，我們能夠追蹤哪個函數正在執行。  用我們上面的例子來看執行棧如何運作：  ```js function hello(myName) {   let name = myName;   function sayHi() {     console.log(\"hello\", name);   }   sayHi(name); } hello(\"leo\"); ```  我們可以用程式碼來模擬執行棧的運行:  ```js let callStack = []; // 1. 別忘記一運行程式碼時，全局上下文會被創建，此時會被推入棧。 callStack.push(\"global\"); // callStack = ['global']  // 2. 執行 hello('leo'), 此時 hello 的上下文被推入棧 callStack.push(\"hello\"); // callStack = ['global','hello']  // 3. 執行 sayHi(name), 此時 sayHi 的上下文被推入棧 callStack.push(\"sayHi\"); // callStack = ['global','hello','sayHi']  // 4. sayHi 執行完畢，推出棧 callStack.pop(); // callStack = ['global','hello']  // 5. hello 執行完畢，推出棧 callStack.pop(); // callStack = ['global']  // 6. 關閉瀏覽器 callStack.pop(); // callStack = [] ```  ## 總結  我認為執行上下文在理解 `javascript` 有很大的幫助，牽扯到很多概念。 例如: `this` 、`閉包`、`變數提升`、`作用域鏈`。   如果搞熟了，對於一些行為也不會覺得很奇怪了。  ## 參考  [你真的了解执行上下文吗？](https://juejin.cn/post/6945240902625394718) "},{title:"作用域與作用域鏈",path:"/posts/JS%E5%9F%BA%E7%A4%8E/%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%8F%88.html",strippedContent:' ## 作用域  作用域是指可以訪問變數或函數的區域。  用一個例子來說明:  ```js function hello() {   let text = "hello";   console.log(text); }  hello(); // hello console.log(text); // text is not defined ```  當呼叫 `hello` 函數時, 我們可以透過變數 `text` 正常打印出 `hello` 字樣，可是當在 `hello` 函數外使用 `text` 變數時，則會報錯。正是作用域導致我們無法從函數外部訪問到 `text` 變數。  ## 作用域種類  而什麼情況會產生作用域呢?   在 `javascript` 中，共有四種方式會產生作用域。  1. 全局作用域 - 簡單來說在程式碼一運行時，就會自動產生一個大家都可以訪問的作用域。 2. 函數作用域 - 發生在創建函數時，會產生的作用域，僅能夠在函數內訪問。 3. 模塊作用域 - `ES6` 引入模塊化後，每個模塊都會有各自的作用域。順帶一提，`ES5` 以前則是用函數來隔離變數環境。 4. 塊作用域 - `{ }` 包覆住的程式碼， 在 `ES6` 引入的 `let`、`const` 變數宣告，可以只存在塊作用域中。  ## 作用域的產生  在 `javascript` 中使用的是靜態(詞法)作用域。   當程式碼編寫完成後，則已經確定作用域了，而非執行階段。  ## 作用域鏈  那麼每個作用域都只能訪問當前的作用域嗎?   如果是這樣設計的話，會變得很不彈性。  例如: 當想時做一個計數器功能，每次呼叫 `add` 方法時會 `+1`  ```js function counter() {   let count = 0;   function add() {     count++;     console.log(count);   }   return {     add,   }; } let countController = counter(); countController.add(); // 1 countController.add(); // 2 ```  在我們能訪問其他作用域的情況，很好的能保存變數被改變的情況。而若不能訪問其他作用域的情況下，上面代碼有辦法實現嗎?  那麼又衍生一個問題，為什麼上面的 `add` 函數能夠訪問到 `counter` 函數下的 `count` 變數呢?  這其實就是作用域鏈所造成的，`javascript` 會依照當前作用域去尋找是否存在該變數，若沒有的話就會往父層作用域去尋找，直到最上層的作用域(全局作用域)。 '},{title:"2022總結",path:"/posts/%E5%BF%83%E5%BE%97/2022%E7%B8%BD%E7%B5%90.html",strippedContent:" 從 2019 開始買了第一顆以太後，陸陸續續玩了很多幣圈內的項目。 從 defi、NFT、gamefi 還去玩了一下合約炒炒幣，但是始終沒有想過身為技術人員，怎麼不從技術層面去理解區塊鏈相關技術呢?  所以在去年決定了某一項今年目標就是從技術方面深入區塊鏈產業。  ### 2022  一月份用 udemy 的 某一個 NFT 課程學習，學到了如何寫 solidity 合約。   為了更加熟悉 solidity , 參加了人生第一個 區塊鏈黑客松[Integrating UNS “Login With Unstoppable”](https://gitcoin.co/issue/27487)  - [guess-to-win-NFT](https://github.com/LeoWangJ/guess-to-win-NFT)    是一個很簡單的選號碼抽獎的頁面，雖然那時還沒辦法解決隨機性的問題(後來知道了如何透過預言機處理)，所以其實已經把答案寫在合約裡了...   不過秉持著初學者的態度，有實作出來已經對自己是很大的鼓勵了!  - NFT mint 合約    二月時透過 Azuki 項目學了當時 NFT 比較流行的 mint 合約的整個流程，荷蘭拍、Merkle Tree 實現白名單設置、禁止科學家 mint、ERC721A 怎麼省 gas fee 等等...    雖然經過了十個月早都忘光了，但是有了這次的學習，要回顧熟悉下肯定是比第一次看時來的輕鬆。  - NFT 生成器    理解了 mint 所需的流程後，打算做一個 NFT 生成器 [(參考)](https://nft-generator.art/)，   用戶提供各個部件的圖片後，透過技術層面去合成圖片，並且能夠設置稀有度，生成之後能夠幫用戶部署合約、以及上傳圖片的 metadata 至 IPFS。    只可惜與朋友一起開發後，剩下合約自動部署以及購買我們服務的部分，當時是沒有能力能夠實做出來的。     但是說不定未來有一天還會回去完善功能，當作是 side project 也是很有趣的!    做了生成器部分與 landing page 也花了我們兩個月的時間，這個 side project 從設計、功能發想、未來需要什麼功能，都是我們參考竟品以及自行研究所得出來的。     經過了這兩個月的時間，也深深明白創業是多麽不容易，除了技術之外，其他方面我都是欠缺的！  - 疫情    因為疫情的關係，所以居家了( 5, 6, 7 月)。     居家辦公除了工作之外有在寫程式，基本上就徹底躺平了，因為那時候就跑去玩了兩三個月的小圖片 哈哈哈。     只可惜還是沒研究出來如何自動 mint 那些小圖片合約，有點可惜  - 第二次參加區塊鏈黑客松    耍廢了三個月，回公司後突然想起了當初想透過技術暸解區塊鏈項目這件事，也想順便賺點外快就決定再次參加黑客松。     也給自己定下一個目標，參加 30 次黑客松 只要得獎一次就算成功！    選擇了[Token & NFT Wallet With Vault Manager](https://gitcoin.co/issue/29154) 這個項目做了第一個區塊鏈相關的錢包 [Ieyasu](https://github.com/LeoWangJ/Ieyasu)    這一個月下班、假日基本上就是在做 Ieyasu，常常搞到半夜，隔天又要早起上班。     回想起來都很佩服自己想把它完成的決心 哈哈哈。     至於學到了什麼知識呢? 除了串接錢包、交易、合約調用外，最大的收穫就是能夠快速做成一個 MVP、設計、產品原型都自己來。    雖然最後沒有獲獎，但是當看到有十幾個人投票給我的項目時，對我來說已經很滿足了，因為有人認同我的項目！  - 九月回歸前端與第三次黑客松    由於距離下次黑客松還有一段時間，所以就跑去學了[神三元的 深入浅出 Vite](https://juejin.cn/book/7050063811973218341) ，理解了 `pre-bundle`、`plugin`、`HMR` 等相關知識，並且跟著文章內容一步一步實現[小型的 vite](https://github.com/LeoWangJ/learn-vite)。    月中時剛好有了一個黑客松[ Metamorphosis Bounty](https://gitcoin.co/issue/29314)，   在 Tezos 鏈上建造一個 [可視化生成 NFT ](https://github.com/LeoWangJ/vsualization-generator-nft) 結合了[ TZNFT CLI ](https://github.com/oxheadalpha/nft-tutorial/tree/master/packages/tznft) 這個現有的工具，因為非技術人員，大多不太會用這種工具，所以想到了這個主題能服務更多大眾。     這個項目困難的點是，`cli` 的程式碼很多都是 `Node.js` 的功能，所以在網頁上必須使用許多 `Node.js polyfill` 去解決這問題，解決了就沒什麼難點了，所以只花了七天就完成這個項目。     不過神奇的是竟然獲得了第二名，我是完全沒預料到...  - Vue3 源碼 與演算法    學習[Vue 源碼](https://github.com/LeoWangJ/learn-vue3-sourcecode)與[複習演算法](https://github.com/LeoWangJ/DSA-SuXun)也是去年給今年的目標，不過沒想過到了快十月才開始這計劃，也沒想過原本要學 Vue2 源碼到今年就變 Vue3 了...    不過這兩個進度確實很緩慢，Vue3 只學習到了響應式原理部分、算法方面則刷了快 50 題，剩動態規劃、分治、回朔 一些比較難的概念還沒刷。     明年勢必要再把這兩個坑填上！  - 今年的最後一次黑客松    [Ylide Wallet-To-Wallet Communication Bounty](https://gitcoin.co/issue/29558) 是今年參加的最後一個黑客松，也是最讓我驚喜的一次，因為我得了第一名！     [electron-ylide-chat](https://github.com/LeoWangJ/electron-ylide-chat) 是一個桌面型的通訊軟體，也是第一次用 electron 技術去實作。 在 electron 中要使用錢包的困難度確實挺大的，光研究這部分就花了快兩個禮拜。     所以只剩兩個禮拜讓我完成剩餘功能...    這個項目的話，可能後續還會繼續完善成真實產品，因為 Ylide 項目方以及其投資人蠻希望看到他能夠成為產品的。     對於開發者而言，有人期待、使用自己所做的項目，是一種特別有成就感的事情！  ### 公司  上半年還是一樣在維護、開發原有專案，而下半年公司計劃要做新的影視產品。    這對我來說也是相當好的機會，終於能夠使用 Vue3、Typescript、原子化 css，來構建新項目，加強項目的可維護性。    這也是為什麼從 Vue2 改看 Vue3 源碼的原因。    今年在公司的最大的成長反而不是技術層面上的，而是對於需求的合理性、以及需求如何用更好的方式來解決上有了更多的思考。    並且除了別人提的需求之外，自己也能夠提出一些需求來解決當前產品問題。   例如：  - 影片的列表是採用無限加載方式去加載下一頁，只要從影片觀看頁回到影片列表頁上，又必須從第一頁開始 load， 想了許多方案後，決定使用 keep-alive 去做緩存。 - 透過 GA 發現許多用戶進入頁面時都是在影片觀看頁，這說明了許多人複製連結給朋友看。 所以向主管提了要實作分享功能。  另外移動端也改用混合式 APP 來做，使用了 cordova 進行打包處理，不過確實還是踩了蠻多的坑(兼容性問題)。    最大問題是現今用 cordova 打包已經較少見了?! 相關生態系的插件很多都已經沒在維護了，導致要使用那些插件，必須要有自己改造的能力，也就是使用 java ，但是沒寫過的我沒辦法解決該問題。  最近公司打算擴展第二個影視產品，沒意外就會使用 monorepo 方式去開發了吧！  ### 總結  原本想說今年沒什麼可以寫的內容，但是寫著寫著發現寫了比之前的都還多?!   不知不覺一年也做了很多事情，要用一句話來總結的話，就是『做就對了』！   先有執行力再邊做邊修正，總比規劃了很多卻一步都不走好得多。  希望明年能把之前未完成的事情做完，把自己覺得困難的事情克服。  ### 明年目標  1. 複習算法 (200 題) 2. 複習前端相關知識 3. vue3 源碼  明年上半年首要目標是深入前端方面，讓自己競爭力更上一層樓，有了競爭力後選擇就會更多。  4. 英文聽說 5. 後端一個中型項目 6. 合約項目  下半年克服英文，在 Metamorphosis Bounty 得獎後，項目方有詢問說是否要將項目完善好，但是需要用線上面談的方式。   但是因為我英文不好，無法進行口語交流也就錯失這個機會...  接下來後端是從業來一直想學，但是學了又很久沒碰，所以又忘光了！   明年計劃是能夠習慣後端開發的模式，至少會做就好。  合約部分則是最後一項目標，為了黑客松能夠做更多項目，而不大多侷限於前端，因此想多學習合約開發，與後端一樣能開發就行。 "},{title:"2021總結",path:"/posts/%E5%BF%83%E5%BE%97/2021%E7%B8%BD%E7%B5%90.html",strippedContent:" 今年發生了很多不太好事情，導致學習上心態也出現的怠惰，俗稱的躺平吧。   雖然去年所訂的目標只剩 JS高級程序(第四版) 還沒完成，但知識還是要進到頭腦才是吸收，我自己評分的話大概70分吧！   有些知識雖然了解，但並沒有學習到更加深入。     ### 公司 今年公司的產品大多都是維護跟開發 feature 為主，因此並沒有比較有印象的事情， 但比較有印象的就是實作代碼規範化的腳手架吧！   由於公司買回來的專案並沒有 eslint + stylelint 規範，導致有時提交的代碼被 vscode 的自動格式化所改到無關聯的 code ，使得 code review 變得困難。   為了解決這問題，我提出做一個腳手架來配置屬於我們前端團隊的程式碼規範化。   腳手架是使用 Node.js 來撰寫的。 主要流程是，使用者輸入要配置的版本後， 會自動添加 eslint + stylelint + husky + lint-staged 的檔案配置。   有時間的話再將整個架構與詳細開發流程寫成一篇文章吧！     ### 學習 今年在極客時間買了好多課程，包括去年計劃的 HTTP、算法 還有些買了只看幾堂的小冊 XD，  其中購買了一堂前端進階課，有些難度，明年需要把它重新看過一次做複習！  10月份後基本上渾渾噩噩的過日子, 沒什麼目標和動力去學習, 錯失掉了兩個多月的學習時間    ### 外包 在今年最後一個月開始接了一個 defi 項目的前端部分, 雖然目前只有去實作線圖但也是一種新體驗, 但對於我來說算是一個入門區塊鏈產業的一個起點！   明年要把握機會將產業轉成區塊鏈產業中！    ### 明年目標 1. 英文聽說 2. 複習算法 3. 從技術方面深入區塊鏈產業(實作 NFT 平台、 defi 合約)  4. 重溫前端進階課 5. vue2 源碼"},{title:"HTTP 緩存機制",path:"/posts/HTTP/HTTP%E7%B7%A9%E5%AD%98.html",strippedContent:" ## HTTP 緩存  ### What HTTP 緩存是一種優化系統性能的利器，能夠將使用 HTTP 請求獲得到的資料儲存起來，等到下次請求時復用。   減少多次的 HTTP 請求 - 應答的成本，減少網路帶寬及增加響應速度。      ### Why 假如資料沒有變動過的話, 重複請求相同資料非常浪費網路資源，所以使用緩存將其儲存起來，再次取得資源時響應速度也會比直接從服務端請求快上許多。    ### How HTTP 緩存又分為強緩存及協商緩存    #### 強緩存 - expires     為HTTP 1.0 新增的 `header`，使用 `<http-date>` 日期格式來判斷緩存到期時間，是絕對時間。   ```     expires: Wed, 21 Oct 2015 07:28:00 GMT   ```   在 `response header` 中設置 `expires` 字段後，就可以告訴瀏覽器該資源在過期之前可以不用請求。      但是缺點為：     1. 由於是絕對時間，若使用者修改本地時間的話，可能會造成緩存過期而導致失效。          就算未修改本地時間，依照時區或其他因素也可能導致客戶端與服務端時間不一致，導致緩存失效。       2. 日期格式太過複雜，填寫未符合規定的話緩存即無用。   - cache-control     為了彌補 `expires` 使用絕對時間的不足，在 HTTP 1.1 時新增該 `header`， 表示緩存最大的有效時間，瀏覽器也能發送。   ```    cache-control: max-age: 86400 // 能夠緩存24小時   ```   還有其他可選的字段能夠設置 (混合使用) :    - max-age : 資源的有效使用期限 `秒` 為單位，但是這個有效期限是在響應報文離開服務端的時刻，而不是客戶端接收到報文時，也就是說包含傳輸過程中所耗費的時間。     - no-store : 不使用緩存，即每次都會去服務器請求資料   - no-cache : 使用緩存，但每次使用前都會與服務器驗證是否過期與是否有新版本   - must-revalidate : 使用緩存，只要不過期的話就能繼續使用，過期時就必須去服務器驗證   - public : 所有內容都可以被緩存 (包含客戶端和代理服務器)   - private : 只有客戶端內容可以被緩存, 為默認值  在重整(F5) 瀏覽器時會夾帶 `cache-control: max-age:0`，代表資料保存期限已過，需要重新抓取資料。   而強制重整則是帶 `cache-control: no-cache`。    疑問是： 兩者含義基本一樣，但差別在哪呢？   在強制重整時，瀏覽器不會攜帶條件請求(待會介紹)，導致從服務器請求時資源時不會被條件請求所緩存住，而向服務器請求最新的資料。    而瀏覽器的 `前進`、`後退` 按鈕則不會攜帶 `cache-control`，所以會去檢查緩存。     #### 協商緩存 (條件請求) 上面提到強緩存有時需要去服務器驗證是否有最新資源，但是強緩存本身並無法執行驗證這個動作，所以定義了條件請求字段，專門用來驗證資源是否過期，而驗證責任則由服務器端負責。      - Last-Modified : 資源最後一次被修改的時間，由服務端設定 `response header`。     ```    Last-Modified : Mon, 10 Nov 2018 09:10:11 GMT    ```   - If-Modified-Since : 客戶端會將上次服務端 `Last-Modified` 的值存到該字段中，目的用來給服務端驗證資源是否有更新過，若字段對比相同，則回應 `304` 狀態碼，反之則回 `200`。   - ETag : 是資源的唯一標示，能夠精準的識別資源的變動情況。主要用來解決修改時間無法精準區分文件變化的問題，優先值高於 `Last-Modified`。      - 強ETag : 要求資源字節級別必須完全相等 。      - 弱ETag : 只要求資源語意上沒有變化，但內部可能會有部份發生改變(空格或者HTML標籤順序調整)。    - If-None-Match : 與 `If-Modified-Since` 行為大致相同，只是判斷的字段變成 `ETag`。   使用協商緩存並不代表不會發送 HTTP 請求，其優化的部分在於若有緩存，則不攜帶 `body` 內容，從而節省網路帶寬。    ## 參考 - [一文读懂前端缓存](https://mp.weixin.qq.com/s/cUqkG3NETmJbglDXfSf0tg)"},{title:"代碼統一規範化( husky + lint-staged )",path:"/posts/%E5%B7%A5%E7%A8%8B%E5%8C%96/%E4%BB%A3%E7%A2%BC%E7%B5%B1%E4%B8%80%E8%A6%8F%E7%AF%84%E5%8C%96.html",strippedContent:" 由於公司近期購買四個專案回來開發並維護，但並未使用 ESLint 去規範程式碼。另外這些專案大概有三四個前端共同維護，在修改 code 時風格不同或者格式化配置不同而自動格式化更新代碼，導致提交時修改了與feature / bug 無關聯的 code ，導致 code review 困難。所以萌生導入代碼規範化的系統。     \b導入這套系統的好處: - code review 時能專注在檢查 feature or bug 的 code - 保持專案代碼的風格與品質，方便開發者閱讀代碼 - 減少風格的不同帶來的維護成本 - 無需統一開發者的編輯器配置 - 甚至可引入公司全部前端專案, 進而達到風格一致性  ## 插件說明 ### ESLint ESLint 是一種靜態掃描的工具，由於 JS 不像其他的靜態語言能夠在寫代碼時就知道哪邊錯誤並且報出錯誤訊息，使用 ESLint 方便我們控管 Javascript 程式碼的品質。  > 例如: \b強制使用 === 取代 ==      而選擇 ESLint 的原因是插件非常豐富並且規則彈性，能夠依照團隊需求而去進行調整。    ### husky 是一種可以操作 git hooks 的套件，方便我們在提交代碼時能夠執行某些腳本。     而使用 husky 是打算在 commit 之前執行 ESLint 而達到自動檢查代碼規範及自動格式化。 但是執行後會發現除了提交的檔案執行 lint 外，連其他未提交的也一起被檢查了，所以我們需要 lint-staged 來解決這件事。    ### lint-staged 能夠讓 lint 只檢查存在 git stage 區的檔案，這樣的話就能避免全部檔案跑 lint 的問題。  ## 配置文件 由於公司前端框架是使用 Vue 來開發，所以本次將結合 Vue 進行代碼規範統一。  ### ESLint  先安裝ESLint、Vue插件依賴 > npm i -D eslint babel-eslint eslint-plugin-vue   - eslint: ESLint 核心代碼 - babel-eslint: 使 ESLint 能夠在代碼被babel轉譯後運行 - eslint-plugin-vue: Vue 與 ESLint 整合，使得 ESLint 能夠在 Vue 檔案上運行  配置`.eslintrc.js`檔案: ```js module.exports = {   root: true,   parserOptions: {     // 定義ESLint的解析器     parser: 'babel-eslint',     sourceType: 'module'   },   // 指定代碼的運行環境   env: {     browser: true,     node: true,     es6: true   },   extends: [     // ESLint 推薦規則     'eslint:recommended',     // 繼承vue的標準特性     'plugin:vue/essential',   ],   plugins: [     'vue',   ],   rules: {   },   // 當使用第三方的SDK時，ESLint會報找不到，可以加入到globals，取消對這個的檢查   globals: {   } } ```  ### Standard code style 由於公司其他專案也是使用 ESLint + Standard 標準，所以這邊規則會使用 [Standard的規範](https://standardjs.com/rules-zhtw.html)。  安裝 Standard 依賴 > npm i -D eslint-config-standard eslint-plugin-standard eslint-plugin-import eslint-plugin-node eslint-plugin-promise  - eslint-plugin-standard: ESLint 的 Standard 規則插件 - eslint-config-standard: 關閉與 Standard 有衝突的 ESLint 規則 - eslint-plugin-import,eslint-plugin-node,eslint-plugin-promise: `eslint-config-standard` 的依賴，若未安裝則無法進行\b。    修改上述`.eslintrc.js`配置: ```js extends: [   // ESLint 推薦規則   'eslint:recommended',   // 繼承vue的標準特性   'plugin:vue/essential',   // 添加Standard規範   'standard' ], ```  若檔案不希望進行檢查，則可新增`.eslintignore`檔案 ``` // .eslintignore build/*.js src/assets public dist ``` ### husky + lint-staged配置 先安裝套件 > npm i -D husky lint-staged  進行\b package.json 配置： ```json \"husky\": {   \"hooks\": {     \"pre-commit\": \"lint-staged\"   } }, \"lint-staged\": {   // 需先進行 lint 檢查   \"src/**/*.{js,vue}\": [     \"eslint --fix\"   ] } ```   ## 執行流程  1. 提交代碼( git commit )   2. 透過 husky 執行 pre-commit 的 git hooks，調用 lint-staged。  3. lint-staged 對儲存在 git stage 區域的檔案依序執行寫好的任務( ESLint )。  4. 若有錯誤則停止任務，需修復完成後再執行步驟1。  5. 若無錯誤則進行 git commit。    ## 參考 [提升專案品質及一致性](https://medium.com/@danielhu95/set-up-eslint-pipeline-zh-tw-990d7d9eb68e)   [Vue 项目接入 Eslint + Prettier + Husky 格式化代码](https://zhuanlan.zhihu.com/p/159729783)   [quasar Lint Rules](https://quasar.dev/quasar-cli/linter#Lint-Rules)   [eslint + husky + prettier + lint-staged 提升前端应用质量](https://juejin.cn/post/6844903778227847181#heading-5)  "},{title:"ch02 - HTML中的JS",path:"/posts/JS%E9%AB%98%E7%B4%9A%E7%A8%8B%E5%BA%8F/HTML%E4%B8%AD%E7%9A%84JS.html",strippedContent:' 要將 JavaScript 引入網頁的話，首先必須解決與網頁的主導語言 HTML 的相關問題。要如何兼容到 HTML? 最終使用&lt;\\script&gt;來加載腳本。  ## script 元素  提供八種屬性，這裡只介紹其中幾個常用的  1. defer: 能夠使腳本先被加載，等到頁面解析至&lt;/html&gt;時才會執行腳本內容 2. async: 與 defer 相似，但在加載時不會按照腳本順序去執行。 3. type: 代表腳本語言的內容類型。module 代表 code 會被當作 ES6 模塊，能夠使用 import 與 export。 4. src: 加載外部腳本的來源路徑。  ## 加載順序  腳本在被加載時(包含內聯腳本)會是由上往下的依序執行。並且在執行時不會執行其他內容，所以容易導致畫面渲染被阻塞。為了避免畫面空白時間過久，通常會將&lt;script&gt;放到&lt;/body&gt;前來達到優化的效果。  ## 動態加載腳本  除了使用&lt;script&gt;去加載外，還可以使用 JS 去加載腳本，但難以管理從哪邊加載的。要讓預加載器知道有哪些動態腳本存在，可以在&lt;head&gt;裡聲明:  > &lt;link rel="preload" href="a.js"/&gt; '},{title:"2020總結",path:"/posts/%E5%BF%83%E5%BE%97/2020%E7%B8%BD%E7%B5%90.html",strippedContent:" ### 起 這是第一次做總結，這個blog大約在換第二份工作時創的，原先想說要開始記錄工作與學習心得的，但是後來發現篇幅小的就寫在hackmd或者github上，而且越來越懶就沒寫了XD     想說在2020最後一天做一下今年總結，期許明年可以依照原先計畫多寫幾篇文章。    ### 工作  去年的時候自己剛完成第一個以Vue全家桶為架構的專案，而今年因為業者新需求而需要將原先專案的某些功能刪除並且因風格與畫面設計完全不同，所以與主管討論後決定另開一個專案來開發比較好維護。      雖然這個電腦版專案與先前專案功能大多相同，但UI不同產生的挑戰也就不同。並且增加了一位小夥伴和我互相CodeReview 程式碼出錯率減少與質量得到提升。    年中的時候因為疫情影響公司發展策略也稍微有做調整，所以多了一個以前沒有做過的專案性質(影視)。      這個產品還是蠻有趣的，是我第一次用Vue開發的手機版專案(quasar框架)學習到蠻多。 1. 由於先前專案沒有統一ESlint配置所以導致兩人開發時風格不太統一，後來在這個專案中解決了這個問題    2. 使用rem開發 3. 了解圖片大小自動按比例呈現 4. JS的random方法並非真正隨機，所以使用洗牌算法來呈現影片隨機畫面 5. 知道HLS 協議, 還有他的加密運作機制 6. 使用axios cancel方式解決快速切換tabs後造成先前請求資料未被取消而資料顯示錯誤的問題  今年不知不覺在修bug時會去看UI框架的源碼，主要是因為有些文檔寫不清楚或者出於好奇才去查看，開始沒以前那麼害怕看源碼了～      ### 外包 剛好因緣際會下朋友的網站需要維護，而幫他維護。順便熟悉一下react生態圈  ### 學習 今年學習也是斷斷續續的，這邊學一點那邊學一點，明年需要學習並且記錄下來！    1. 資料結構與演算法 2. 好奇axios cancel的方式而去學習axios源碼 3. Node.js以及使用docker本地架mysql及redis 4. 學習部署阿里雲 5. Vue3 6. Typescript  ### 明年目標  1. JS高級程序(第四版)  2. 學習CI/CD 3. 將公司前端工程化完善(代碼規範 & git 提交規範) 4. 透視HTTP協議 5. 資料結構與演算法"},{title:"JS各種繼承方法以及如何用ES5實現ES6的class",path:"/posts/JS%E5%9F%BA%E7%A4%8E/inherit.html",strippedContent:' \b\b\b  ## 構造函數繼承  構造函數繼承的概念就是子函數透過 call,apply 方式去調用要繼承的父層構造函數。 缺點是我們無法調用父層的 Prototype 並且由於構造函數返回的實例都是各自獨立的，所以我們沒辦法創建一個共用的方法或屬性。  ```js let Parent = function() {   this.child = [] } Parent.prototype.hello = function() {   console.log(`你好，我是你爸爸`) }  let Child = function(name) {   Parent.call(this)   this.name = name } let leo = new Child("leo") leo.name //  leo leo.child.push(leo.name) leo.hello() // not a function  let jack = new Child("jack") jack.child.push(jack.name) leo.child === jack.child // false ```  ## 原型鍊繼承  為了解決 Parent.prototype 無法繼承的問題，我們採用原型鏈來繼承。 而這樣又延伸一個問題，原本使用構造函數繼承時，我們產生的實例皆是獨立的， 但是繼承 Parent 後，Parent 產生的實例也掛載到 Child.prototype 上導致實例被共用。  ```js let Parent = function() {   this.child = [] } Parent.prototype.hello = function() {   console.log(`你好，我是你爸爸`) }  let Child = function(name) {   this.name = name } Child.prototype = new Parent() let leo = new Child("leo") leo.name // leo leo.child.push(leo.name) leo.hello()  let jack = new Child("jack") jack.child.push(jack.name) leo.child === jack.child // true ```  ## 組合型繼承  上述兩種方式都各有缺點，那麼我們如果將兩種方法結合後，是否就能解決這問題呢？  ```js let Parent = function() {   this.child = []   console.log("Parent function") } Parent.prototype.hello = function() {   console.log(`你好，我是你爸爸`) }  let Child = function(name) {   Parent.call(this)   this.name = name }  Child.prototype = new Parent() let leo = new Child("leo") leo.name // leo leo.child.push(leo.name) leo.hello()  let jack = new Child("jack") jack.child.push(jack.name) leo.child === jack.child // false ```  透過上面的方式我們的確解決了 child 屬性私有化以及可以調用父層的 hello 方法。 但上述方式會重複調用 Parent 函數，造成不必要的調用，所以我們來想辦法優化他。  ## 優化組合型繼承 1  如何讓 Parent 不會重複調用並且又可以達成上面的功能呢？ 我們可以使用 Object.create 來創造一個全新的 Parent.prototype 物件。 註: 若使用 Child.prototype = Parent.prototype 會導致內存共享而可能會不小心修改到 Parent.prototype 上的方法。  ```js let Parent = function() {   this.child = []   console.log("Parent function") } Parent.prototype.hello = function() {   console.log(`你好，我是你爸爸`) }  let Child = function(name) {   Parent.call(this)   this.name = name }  Child.prototype = Object.create(Parent.prototype)  let leo = new Child("leo") leo.name // leo leo.child.push(leo.name) leo.hello()  let jack = new Child("jack") jack.child.push(jack.name) leo.child === jack.child // false  leo.constructor === Parent // true ```  這樣我們解決了父層構造函數調用兩次的問題。 而其實組合繼承一開始就有個問題存在，那就是 Child 的實例的 constructor 卻是指向到 Parent 上。  ## 優化組合型繼承 2  由於我們要精確的判斷實例是來自哪個構造函數時，必須使用 constructor 來做判斷。 而這個問題產生是因為我們將 Child.prototype 直接等於另一個物件，導致原本自動產生的 constructor 不見了， 所以要解決這個問題的方式就直接將 contructor 再加回去即可。  ```js let Parent = function() {   this.child = []   console.log("Parent function") } Parent.prototype.hello = function() {   console.log(`你好，我是你爸爸`) }  let Child = function(name) {   Parent.call(this)   this.name = name }  Child.prototype = Object.create(Parent.prototype) Child.prototype.constructor = Child let leo = new Child("leo") leo.name // leo leo.child.push(leo.name) leo.hello()  let jack = new Child("jack") jack.child.push(jack.name) leo.child === jack.child // false  leo.constructor === Parent // false leo.constructor === Child // true ```  ## 使用 ES5 模擬 ES6 class  透過上面的最終版的組合繼承，我們就可以用 ES5 來模擬 ES6 的 class。  ES6 版本  ```js class Parent {   constructor() {     this.child = []   }    hello() {     console.log(`你好，我是你爸爸`)   }    static money() {     console.log("老爸的私房錢")   } }  class Child extends Parent {   constructor(name) {     super() // 調用父層構造函數     this.name = name   } }  let leo = new Child("leo") leo.name // leo leo.child.push(leo.name) leo.hello() leo.money() // not a function ```  我們使用 ES5 來寫看看  ```js let Parent = function() {   this.child = []   console.log("Parent function") } Parent.prototype.hello = function() {   console.log(`你好，我是你爸爸`) } // 直接在Parent下創建方法即可模擬私有函數 Parent.money = function() {   console.log("老爸的私房錢") } let Child = function(name) {   Parent.call(this)   this.name = name }  Child.prototype = Object.create(Parent.prototype) Child.prototype.constructor = Child let leo = new Child("leo") leo.name // leo leo.child.push(leo.name) leo.hello() leo.money() // not a function ```  經過這些內容後，對於 javascript 繼承的概念又更加熟悉了。  讓我想起以前第ㄧ次寫 React 時，對於 super()這個方法完全不熟悉，還以為是 React 自己的方法 XD '},{title:"談談構造函數(constructor)與原型(prototype)的設計",path:"/posts/JS%E5%9F%BA%E7%A4%8E/prototype.html",strippedContent:" 本文將會談到 - 構造函數\b(constructor)是什麼? - 原型(prototype)是什麼? - prototype與__proto__ 關聯性 - \bnew操作符實際做了什麼事? - 如何查找原型方法及屬性  ## 前言 由於JS作者在開發時，是將其定位在簡單的腳本語言，所以就沒打算引入Class的概念。但是又需要設計繼承的概念，方便將物件關聯起來。所以最終作者還是設計了繼承。  作者設計繼承時參考了JAVA生成實例的方法: ```js Foo foo = new Foo() ``` 但是JS沒有Class(ES6的Class只是語法糖)，那要怎麼表示呢？ 他想到JAVA使用new 命令時，都會調用Class的構造函數(constructor)。所以他就做了一個簡化的設計，在JS語言中，new命令後面調用的不是Class而是構造函數(constructor)。  ## 構造函數\b(constructor)是什麼? 構造函數其實就是物件的模板，方便我們重複調用相同格式的物件實例。順帶一提構造函數與函數的差別在於呼叫的方式不同，用new呼叫的函式就為構造函式。  ```js let Car = function(name,color,amount,countryTax){     this.name = name     this.color = color     this.amount = amount     this.tax = function(){         return amount * countryTax     } }  let car1 = new Car('toyota', 'yellow','700000','1.2') console.log(car1.name,car1.tax()) // toyota 840000 let car2 = new Car('BMW', 'black','1200000','1.3') console.log(car2.name,car2.tax()) // BMW 1560000 ```  根據上面的例子，構造函數生成出來的物件實例各有自己的屬性與方法，無法共享。這有好處也有壞處，好處是修改屬性時不會全部實例跟著改變;而壞處就是共用的方法或屬性在每次創建實例時都會被創造出來，造成記憶體的消耗。為了解決這個問題，作者在函數中設置了一個prototype屬性。  ## 原型(prototype)是什麼? 原型讓我們不需要再重複創建一個屬性或者方法，它可以讓我們將共用的方法放到一個物件中。 prototype是函式中會自行創建的一種物件。當創建一個實例時，會自動將原型綁定到該實例上。  ```js let Car = function(name,color,amount){     this.name = name     this.color = color     this.amount = amount }  Car.prototype.tax = function(countryTax){     return this.amount * countryTax } let car1 = new Car('toyota', 'yellow','700000') console.log(car1.name,car1.tax('1.2')) // toyota 840000 let car2 = new Car('BMW', 'black','1200000') console.log(car2.name,car2.tax('1.3')) // BMW 1560000 console.log(car1.tax === car2.tax) // true, 這表示了來自同一個函式 ```  那麼到底car1.tax是怎麼知道要從哪邊去找tax這個方法呢? 將car1打印出來後會發現有一個方法__proto__, 查看後有tax這個方法，看起來就是透過這個方法去繼承的。  ## prototype與__proto__ 關聯性 這個__proto__(應該用Object.getPrototypeOf會更嚴謹，但為了方便我們使用__proto__來描述)也是JS自動生成的，他只會存在物件當中，是用來獲取創造實例的構造函數的原型，也是實現原型鏈的原理。  ```js let Person = function(){} Person.prototype.hello = function() {     console.log('hello') } let leo = new Person()  leo.hello() // 通過__proto__原型鏈使用Person.prototype的方法 leo.hasOwnProperty() // 通過__proto__原型鏈使用Object.prototype的方法  leo.__proto__ === Person.prototype // true Person.__proto__ === Function.prototype // true  ```  值得注意的是Person.\\_\\_proto\\_\\_ 繼承的是Function.prototype。函式也是物件的一種，在函式中同時擁有__proto__與prototype。  那麼什麼時候__proto__指向構造函數的prototype呢? 這就與new有關聯。  ## new操作符實際做了什麼事? 在上面的那些例子中，我們知道new 一個構造函數後所產生的實例是物件並且原型指向構造函數的prototype。除了這些new還做了什麼?  其實new一共幫我們做了四件事情: 1. 新增一個物件 2. 將構造函數的prototype指向物件的__proto__ 3. 呼叫構造函數並且使用新增的物件當作this傳入 4. 若呼叫的構造函數有返回物件則返回(若是一般屬性則不返回)，若無則返回新增的物件  ```js // con - 構造函數 // arg - 參數 function fakeNew(con,...arg){     let obj = {}     Object.setPrototypeOf(obj,con.prototype) // obj.__proto__ = con.prototype     let result = con.call(obj,...arg)     return typeof result === 'object' ? result : obj }  let Person = function(name,age){     this.name = name     this.age = age }  Person.prototype.hello = function() {     console.log(`hello, ${this.name} , age = ${this.age}`) }  let leo = fakeNew(Person,'leo',18) leo.hello() // hello, leo , age = 18 ```  ## 如何查找原型繼承及方法屬性 - instanceof - isPrototypeOf - constructor判斷 - hasOwnProperty - in  ### instanceof  這個方法是用來判斷實例是否繼承某個構造函數  > 實例 instanceof 構造函數  ```js let Person = function(name,age){     this.name = name     this.age = age }  Person.prototype.hello = function() {     console.log(`hello, ${this.name} , age = ${this.age}`) }  let leo = new Person('leo','18') console.log(leo instanceof Person) //true console.log(leo instanceof Object) //true ``` 根據上面例子，我們可以知道構造函數只要是有在原型鏈上就會為true，並不是判斷生成該實例的構造函數。 這個方法其實很好自我實現  ```js /** * instance - 實例  * con - 構造函數 */ let polyfillInstanceof = function(instance,con){  if(!instance) return false   return instance.__proto__ === con.prototype ? true : polyfillInstanceof(instance.__proto__, con) } ```  ### isPrototypeOf 這個方法基本上完全與instanceof相同，只是參數位置不同 > 實例.isPrototypeOf(構造函數)  ```js leo.isPrototypeOf(Person) // true leo.isPrototypeOf(Array) // false ```  ### constructor 若想要知道實例真正繼承哪個構造函數時，我們可以用constructor方法來判斷  ```js leo.__proto__.constructor === Person // true leo.__proto__.constructor === Object //false  ```  ### hasOwnProperty 這個方法能判斷是否擁有該屬性或者方法，這使我們能夠判斷該方法與屬性是來自哪裡  ```js leo.hasOwnProperty('name') //true leo.hasOwnProperty('name') //true leo.__proto__.hasOwnProperty('hello') //true ```  ### in in與hasOwnProperty一樣都是用來查找方法與屬性，差別在與只要方法與屬性有存在實例或原型鏈上，就會返回true ```js 'name' in leo // true 'hello' in leo // true ```  ## 參考 - [該來理解 JavaScript 的原型鍊了](https://blog.techbridge.cc/2017/04/22/javascript-prototype/) - [从__proto__和prototype来深入理解JS对象和原型链](https://github.com/creeperyang/blog/issues/9) - [原型与原型链详解](https://github.com/ljianshu/Blog/issues/18) - [Javascript继承机制的设计思想](http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html)"},{title:"『你不知道的JS』- 型別與文法",path:"/posts/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS/%E5%9E%8B%E5%88%A5%E8%88%87%E6%96%87%E6%B3%95.html",strippedContent:" ### 內建型別  JS內建七種型別分別是: 1. null 2. undefined 3. number 4. boolean 5. string 6. symbol (ES6新增) 7. object  當中只有object是引用型別其餘則是一般類型，那麼這兩種類型又有什麼區別呢？   這就需要先說JS是怎麼保存變量。  #### 引用型別與一般類型  在賦值給一個變量時，會將變數與值類似於key:value方式存在一個空間中，我們可以將它先叫做變數對象。  變數| 值 ---|--- a1 | 0 a2 | 'hello' a3 | null a4 | 0x0012ff3d  有注意到上面的一個值是地址嗎？ 那個地址可以連結到另一個空間，叫做heap空間，是提供給引用類型儲存其創建的key/value。   因此我們必須使用變數對象上地址值去找到heap空間所對應的地址值  0x0012ff3d ||   ----|------ key | value name| 'leo' age | 18  我們透過0x0012ff3d 找到了變數a4 的值是 { name:'leo', age: 18 }。  ### 型別檢查(typeof)  JS 提供一個關鍵字能夠檢查型別那就是typeof。  ```js typeof 1 // 'number' typeof '1' // 'string' typeof undefined // 'undefined' typeof true // 'boolean' typeof {} // object typeof [] // object typeof function(){} // function typeof null // object  ```  內建型別中檢查出來的型別基本上與自己的型別是相同的，但只有一個例外就是null，這是作者留下的bug。 比較特別的是屬於物件的子類型函數是function但array也是物件的子類型卻是object。  所以對於檢測引用類型來說，可以使用instanceof來判斷該變量是有存在檢測值的構造函數。  ```js [] instanceof Array  //true ({}) instanceof Object  //true (function fn() {}) instanceof Function // true  [] instanceof Object // true (function fn() {}) instanceof Object // true ```  但若檢測值為Object是沒什麼意義的，因為所有引用類型都是Object。 "},{title:"Vue的表單驗證套件 - VeeValidate!",path:"/posts/vue/veeValidate.html",strippedContent:' 在做表單時總是需要告訴使用者輸入是否正確，所以我們需要去驗證輸入文字是否符合規則，並顯示錯誤。   透過這個驗證套件我們能夠更快速的驗證錯誤，至於我為何會選擇VeeValidate呢？   因為他目前還有持續在維護並且star數也蠻多的，代表使用者有一定的量！接下來就來介紹囉    ## 安裝與usage ```js npm i vee-validate --save ```  安裝完後需要在main.js中import並使用VeeValidate    ```js import Vue from \'vue\' import VeeValidate from \'vee-validate\'  Vue.use(VeeValidate) ``` 此時就能使用VeeValidate了！ 簡單的範例: ```js <input v-validate="\'required|email\'" name="email" type="text"/> //name屬性是需要告訴套件哪個輸入框驗證錯誤; v-validate裡面則是條件 <span>{{errors.first(\'email\')}}</span> // 若驗證未通過時，則會顯示文字 ```  ## 語法 可以透過字串去定義要驗證的規則若規則不止一項可以透過 ｜ 來添加 ```js  const single = \'required\' // 單一規則  const multiple = \'required|numeric\' // 多個規則 ``` 當然也可以用物件方式來呈現，一切看你的習慣 ```js const single = { required: true} const multiple = {   required: true,   numeric: true,   email: true } ``` 另外有些驗證規則會有些參數，也可以使用上面的方式呈現 ```js // 驗證規則:必須包含1,2,3其中一個數字 const someRule = \'included:1,2,3\' //透過:區分驗證規則與參數 const someRuleObj = {   included: [1,2,3] //物件中單個參數時可以使用字串，多個參數時必須使用陣列來包覆參數\b } ``` 當使用字串驗證時必須使用單引號(\' \')來包覆字串，因為Vue會將v-validate中未包覆成單引號的字串當成methods或者prop而導致錯誤    ```js <input v-validate="required" type="password" name="password" > // 錯誤 <input v-validate="\'required\'" type="password" name="password" > // 正確 ```  ## 錯誤顯示 所有取得錯誤的方法都會存在errors這個物件實例裡,以下我們來介紹顯示錯誤的幾種方法。  1. 同個欄位下顯示單個錯誤 2. 同個欄位下顯示多個錯誤 3. 顯示全部欄位的錯誤  ### 同個欄位下顯示單個錯誤  這是官方預設的顯示錯誤方式,是採用fast-exit策略,意思是當有偵測到第一個錯誤資訊時,他的錯誤訊息將會被生成並儲存在errors實例中,而其他錯誤資訊就會被忽略掉    \b使用errors.first(\'欄位名稱\')方法來顯示該欄位的錯誤  ```js <input type="text" name="fieldName" v-validate="\'required\'"> <span>{{ errors.first(\'fieldName\') }}</span> ```  ### 同個欄位下顯示多個錯誤  預設是只能顯示第一個錯誤資訊,但是官方有提供continues方法能夠讓你顯示多個錯誤訊息,用法可以查看下面usage   假如你該欄位的錯誤訊息不止一個時,可以使用errors.collect(\'欄位名稱\')方法來顯示所有錯誤   ```js <input type="text" name="fieldName" v-validate.continues="\'required|alpha|min:5\'"> <ul>   <li v-for="error in errors.collect(\'fieldName\')">{{ error }}</li> </ul> ```  ### 顯示全部欄位的錯誤  若要顯示全部欄位的錯誤時,可以使用errors.all()方法來呈現  ```js <input type="text" name="first" v-validate.continues="\'required|alpha|min:5\'">  <input type="text" name="second" v-validate.continues="\'required|alpha|min:5\'">  <ul>   <li v-for="error in errors.all()">{{ error }}</li> </ul> ```  另一種方式是使用errors.collect(),但要注意的是他的格式是欄位名稱為key,錯誤訊息為value且是array格式  ```js 格式 {   username: [\'不能為空\'],   password: [\'不能為空\'] }  使用方式 <input type="text" name="first" v-validate.continues="\'required|alpha|min:5\'">  <input type="text" name="second" v-validate.continues="\'required|alpha|min:5\'">  <ul>   <li v-for="group in errors.collect()">     <ul>       <li v-for="error in group">{{ error }}</li>     </ul>   </li> </ul> ```  ## 驗證規則 官方有提供一些驗證規則讓我們可以使用,以下就來介紹各項驗證用法  - after 合法日期(可用date_format來定義日期格式)必須大於target參數欄位     params:     target: 用來判斷的日期     inclusion: 當日期與target日期相同時,是否符合規則,預設為false(不符合)    - before 合法日期(可用date_format來定義日期格式)必須小於target參數欄位     params與after相同  - alpha 僅能輸入英文字 - alpha_dash 能輸入英文字、數字、下劃線(_)與破折號(-) - alpha_num 僅能輸入英文字與數字 - alpha_spaces 僅能輸入英文字與空白\b\b - between 數字介於min與max之間     params:     min: 最小值     max: 最大值   ```html   <input v-validate="\'between:1,11\'" name="between_field" type="text"> ``` - confirmed 判斷兩個欄位之間的值是否相等,必須有ref屬性欄位供comfirmed判斷參考依據的欄位     ```html   <input v-validate="\'required\'" name="password" type="text" ref="password">   <input v-validate="\'required|confirmed:password\'" name="between_field" type="text"> ``` - credit_card 驗證信用卡號 - date_between 驗證所填日期是否介於min與max日期之間     params:     min: 最小日期     max: 最大日期     inclusion  是否包含min與max的日期;預設為false   ```html   <input v-validate="\'date_format:dd/MM/yyyy|date_between:10/09/2016,20/09/2016\'" name="date_between_field" type="text"> ``` - date_format 日期格式,在使用任何的日期規則時,必須傳入 ```html <input v-validate="\'date_format:dd/MM/yyyy\'" name="date_format_field" type="text"> ```  ## 客製化錯誤訊息 如果不喜歡vee-validate 預設的錯誤訊息,官方有提供修改的方式  ## localization 由於我們的用戶不一定是英文語系國家的人,所以我們需要依照地區來顯示相對應語系的錯誤訊息   我會介紹如何載入語系以及客製化錯誤訊息  ```js import zh_CN from \'vee-validate/dist/locale/zh_CN\'  const custom_CN = {   password: {     required: \'密码 不能为空\'   },   username: {     required: () => \'用户名 不能为空\',     min: \'123\'   } }  VeeValidate.Validator.localize(\'zh_CN\', { ...zh_CN, custom: custom_CN }) ```  ## 驗證事件 驗證錯誤的觸發判斷的預設值是監聽input事件的,若想選擇其他的監聽事件,例如change事件等,可以在使用veeValidate時傳入events key來判斷。   可以監聽多個事件判斷,也可以客製化自己的事件 ```js Vue.use(VeeValidate, {   events: \'change|blur|custom\' }); ```  當然你也可以指定某個特定的輸入框,使用data-vv-validate-on   ```js <input name="field" v-validate="\'required\'" data-vv-validate-on="change|custom"> ```  若你想要點擊送出按鈕時才觸發驗證,可以將evnets的值填空字串,這樣就不會觸發input的任何監聽事件 ```js Vue.use(VeeValidate, {   events: \'\' }); ```  也可以對單一個輸入框進行判斷,在v-validate後添加disable ```html <input name="field" v-validate.disable="\'required\'"> ```  若想在發送表單中的函式做驗證判斷 ```js export default {   // ...   methods: {     onSubmit () {       this.$validator.validate().then(valid => {         if (!valid) {           // do stuff if not valid.         }       });     }   }   // ... }'},{title:"Vue 自定義列的Table組件開發",path:"/posts/vue/table-model.html",strippedContent:" ## 前言   當我們在開發專案時，有時很常需要使用表格來顯示資料，但每個表格的標題與內容要展示的都可能不一樣，當表格資料都是純文字時非常的好解決這個問題，但表格內容需要有一些操作時 例如: 需要操作按鈕等等... 這時表格組件規劃起來就特別的麻煩。所以今天要介紹如何在表格組件中攥寫自定義的資料  ## 策略  - 有兩個資料參數(header,data)，header代表標頭的資料、data代表各列要顯示的資料  - 透過slot-scope去顯示自定義資料"},{title:"『JS權威指南』- 類型",path:"/posts/js%E6%AC%8A%E5%A8%81%E6%8C%87%E5%8D%97/ch02-type.html",strippedContent:' ## 數據類型 js的數據類型分成兩類：原始類型(primitive type)與對象類型(object type)。   原始類型包含Number,String,Boolean,null,undefined,Symbol(es6)。    ## 原始類型 創造Number,String,Boolean 變數時可以使用直接量定義,也可以透過new 來創造構建函數。 ```js var num = 9 var str = \'test\' var boo = true  var num1 = new Number(9) var str1 = new String(\'test\') var boo1 = new Boolean(true) ``` 上面兩種創造出來的值是相同的，那這兩種方式有什麼差別嗎？    先來看一個例子  ```js var s = "test"; console.log(s.toLocaleUpperCase()) s.len = 4; var t = s.len; // undefined ```  1.為什麼字串可以使用方法?   2.既然可以使用方法,也能創建屬性,那為什麼t依舊為undefined?    因為當使用字串直接量的方法或者屬性時，JS就會將字串值通過調用new String的構建方式轉成物件，這個物件中有繼承一些方法可以使用，並且被轉成物件後，當然可以添加屬性。   但是因為通過String()構造函數創建的是一個臨時物件，所以當方法或屬性使用結束後，這個物件就會被銷毀，所以導致t為undefined。   所以直接量與new String的差別就在於直接量是當有使用方法或者屬性時才會創建一個臨時物件，而new String則是一開始就已經創建出來了，並且兩者類型也不同。    ``` js var num = 9 var num1 = new Number(9)  console.log(num == num1); // true console.log(num === num1); // falase,因為他們的類型不同  console.log(typeof num); console.log(typeof num1); ```  ## 字串加減乘除  先看一個例子,你能答對嗎？   ```js console.log("10" + "5") console.log("10" - "5") console.log("10" * "5") console.log("10" / "5") ```  答案依序是什麼呢？                    分別就是105,5,50,2 這是因為JS會根據需要來自動轉換類型，那為什麼 + 卻還是一樣是字串呢？   那是因為在兩個字串中的＋被判斷為連接符號，而非運算符號！    '},{title:"『JS權威指南』- 物件object",path:"/posts/js%E6%AC%8A%E5%A8%81%E6%8C%87%E5%8D%97/ch06-object.html",strippedContent:"## 前言 物件是javascript的引用數據類型，可以通過三種方法來創建物件(物件直接量、透過new、Object.create())。   物件可以從一個原型物件繼承屬性，這種『原型式繼承』是javascript的核心特徵。   javascript物件是動態的，意思是你可以對一個物件直接新增屬性，也可以刪除屬性(屬性指的就是物件內的key:value)。   \b物件的屬性中有三種特性，而物件本身也有三種特性，下面我們會深入介紹    ### 屬性特性 **可寫(writable attribute)** : 表明是否可以設置該屬性的值。   **可枚舉(enumerable attribute)** : 表明是否可以通過for in 循環返回該屬性。   **可配置(configurable attribute)** : 表明是否可以刪除或修改該屬性。   在ES5以前通過代碼給物件創建的屬性都是可寫、可枚舉、可配置的，而在ES5後則可以對這些屬性特性加以配置(使用Object.defineProperty)。    ### 物件特性 **原型(prototype)** : Ａ物件繼承Ｂ物件，則Ｂ物件的屬性在Ａ物件中稱為原型。   **類別(class)**: 是一個標示物件類型的字符串。   **擴展標記(extensible flag)**: 是否可以向該物件添加新屬性。    ## 1. 創建物件的三種方法  ### 物件直接量  物件直接量就是最常見的創建物件方式    ``` js   let obj = {}  ```  每次運算上面的表達式時都會創建並初始化一個新的對象(包含物件的原型)。    ### new 方法創建物件  ```js  let obj = new Object() // 創建一個空的物件 {}  ```  透過構造函數(constructor)來初始化一個物件，此種方式與物件直接量其實是一樣的。    ### Object.create() 此方法擁有兩個參數，第一個是這個物件的原型，第二個可選參數是對這個物件的屬性進行近一步描述。   註: 用Object.create創建出來的物件是不會有Object本身的原型即Object.prototype(與上述兩種方式不同)。   ```js  let obj = Object.create({x:1,y:1}) // obj繼承了屬性x和y  let obj2 = Object.create(null) //obj2不繼承任何屬性和方法  let obj3 = Object.create(null,{    p:{      value:1,      enumerable:false // 不可枚舉      writable: false // 不可寫入    }  }) ```   ## 2. 檢測屬性   **以下三種方法可以檢查物件的屬性是否存在**   in 運算符: 用來判斷物件中是否有該屬性，可判斷自有屬性以及繼承屬性\b。  ``` js  var obj = {x: 1}  'x' in obj // true  'a' in obj // false  'toString' in obj // true,為繼承來的屬性 ```  hasOwnProperty(): 用來判斷物件中是否有該屬性，可判斷自有屬性。  ``` js  var obj = {x: 1}  obj.ownProperty('x') // true  obj.ownProperty('a') // false  obj.ownProperty('toString') // false,無法判斷繼承的屬性 ```  propertyIsEnumerable(): 是hasOwnProperty的加強版，可判斷自有屬性且此屬性的可枚舉性為true時，此返回值才會為true  ``` js  var obj = {x: 1}  obj.propertyIsEnumerable('x') // true  obj.propertyIsEnumerable('toString') // false,無法判斷繼承的屬性  Object.prototype.propertyIsEnumerable('toString') // false,不可枚舉 ```  ## 3. 枚舉屬性 要檢測物件的屬性是否存在或者要遍歷物件的屬性時，通常我們都使用for in來遍歷。   要特別注意的是若繼承的屬性中有可枚舉的屬性時，for in 也會將其顯示 ```js var obj = Object.create({x:1,y:2},{   p:{     value:1,     enumerable: true     }   })    for(var i in obj){     console.log(i) // 印出 x,y,p    } ``` 遍歷時要過濾掉繼承的屬性時，可以搭配ownProperty方法   ``` js var obj = Object.create({x:1,y:2},{   p:{     value:1,     enumerable: true     }   })    for(var i in obj){     if( !obj.ownProperty(i) ) continue;     console.log(i) // 印出 p    } ``` 除了for in 外，ES5有提供兩個枚舉屬性名稱的函數。   第一個是Object.keys()，他返回一個陣列，這個陣列由物件中可枚舉的“自有屬性“的名稱所組成。   第二個是Object.getOwnPropertyNames()，與Object.keys類似，只是返回的是物件的所有屬性的名稱(包含不可枚舉的屬性)。   ``` js  var obj = Object.create(null,{     p:{       value:1,       enumerable: true     },     o:{     value:1,     enumerable: false     }   })    console.log(Object.keys(obj)) // return [p]   console.log(Object.getOwnPropertyNames(obj)) // return [p,o] ```  ## 4. 修改屬性特性 上面有提到三種屬性的特性，在創建物件時可以使用Object.create方式去新增屬性特性，那要編輯已存在的物件時該怎麼辦呢？   必須使用Object.defineProperty方法去編輯已存在物件的屬性，這個方法對寫library或者框架的使用者來說是很重要的， 因為可以透過這個API對原型物件添加方法，並將它改成不可枚舉，讓他們看起來更像內置方法。 ```js let obj = {x:3} Object.defineProperty(obj,'x',{ \b// 修改已存在屬性的特性   value: 2,   writable: false,   enumerable: true }) console.log(obj.x) // 2  Object.defineProperty(obj,'y',{ // 也可以對存在的物件新增屬性   value: 2,   writable: false,   enumerable: true }) console.log(obj) // x:2 y:2 ``` ## 5. 序列化物件(serialzation) 指的是可以將物件轉成字串，以及將字串還原成物件   JSON.stringify() : 將物件轉為字串。   JSON.parse() : 將字串還原成物件。   可以使用此種方法進行深拷貝，但無法拷貝不可枚舉的屬性 ```js  let o = Object.create({x:1,y:2},{   p:{     value:2,     enumerable: false   },   o:{     value:3,     enumerable: true   } })  let o2 = Object.create(o,{   r:{     value:2,     enumerable: false   },   k:{     value:3,     enumerable: true   } })  let newO2 = JSON.parse(JSON.stringify(o2)) // 先轉為字串，再轉為物件 console.log(newO2) // {k:3} console.log(Object.getPrototypeOf(newO2)) //取得原型的方法,原型又變成了Object.prototype ``` ## 後續 關於物件還有幾種內建的方法(toString,toJSON...)就不一一介紹了，有興趣的讀者可以自行研究。   看完這個章節後，發現很多API以前都不曉得，對於物件的掌握也比想像中的還低！   只能說javascript這門語言太多地方需要琢磨了～"},{title:"在vue中實現跑馬燈功能",path:"/posts/vue/vue-marquee.html",strippedContent:' ## 前言 在做專案時需要跑馬燈的功能，剛好找到一個open source覺得還不錯，就去理解他實現跑馬燈的代碼思路，順便記錄下來！  ## 代碼思路  - HTML結構會有兩層div，父層為固定，子層存放跑馬燈文字來進行滑動 - 透過css3 動畫 @keyframe 控制 transform: translate3d的X軸來達成文字滑動效果   - 透過getBoundingClientRect來抓取父元素、子元素的寬度，用意是來計算偏移量以及滑動速度 - 監聽watch content變數變動時，透過添加animate class來觸發動畫 - 透過vue $nextTick方法來確保父子元素的寬度是正確的  整體流程為:    監聽content變數是否有變化，有的話開始觸發第一次動畫特效(animate)， 等到第一次動畫結束後觸發onAnimationEnd方法，當onAnimationEnd方法執行時透過animate-infinite動畫方法已達到我們想要的無限滑動。      至於為何不直接就開始觸發無限滑動呢？   因為作者想透過firstRound這個參數來實現我們delay\b參數的效果與判斷開始載入跑馬燈文字時文字的位置  ## 組件參數  變數名稱 | 類型 | 預設 |功能 -------|------|-----|---- content|String|     | 跑馬燈內容 delay  |Number| 0.5 | 第一次動畫延遲時間 speed  |Number| 100 | 速度\b(越大越慢)  ## 組件代碼 ```js  <template>   <div ref="wrap" class="wrap">     <div ref="content" class="content"        :class="animationClass"       :style="contentStyle"        @animationend="onAnimationEnd"        @webkitAnimationEnd="onAnimationEnd">       <slot></slot>     </div>   </div> </template> <script> export default {   props: {     content: {       default: \'\'     },     delay: {       type: Number,       default: 0.5     },     speed: {       type: Number,       default: 100     }   },   mounted () {},   data () {     return {       wrapWidth: 0,       firstRound: true,       duration: 0,       offsetWidth: 0,       animationClass: \'\'     }   },   computed: {     contentStyle () {       return {         paddingLeft: (this.firstRound ? 0 : this.wrapWidth) + \'px\', // 若想第一次載入跑馬燈文字時，文字就在右側則將0改成this.wrapWidth即可         animationDelay: (this.firstRound ? this.delay : 0) + \'s\',         animationDuration: this.duration + \'s\'       }     }   },   watch: {     content: {       handler () {         this.$nextTick(() => {           const { wrap, content } = this.$refs           const wrapWidth = wrap.getBoundingClientRect().width           const offsetWidth = content.getBoundingClientRect().width           this.wrapWidth = wrapWidth           this.offsetWidth = offsetWidth           this.duration = (offsetWidth + this.wrapWidth) / this.speed           this.animationClass = \'animate\'         })       }     }   },   methods: {     onAnimationEnd () {       this.firstRound = false       this.duration = (this.offsetWidth + this.wrapWidth) / this.speed       this.animationClass = \'animate-infinite\'     }   } } <\/script> <style scoped> .wrap {   width: 100%;   height: 24px;   position: relative;   padding: 0; }  .wrap .content {   position: absolute;   white-space: nowrap; }  .animate {   animation: marquee linear; }  .animate-infinite {   animation: marquee-infinite linear infinite; }  @keyframes marquee {   to {     transform: translate3d(-100%, 0, 0);   } }  @keyframes marquee-infinite {   to {     transform: translate3d(-100%, 0, 0);   } } </style> ```  引用組件    ```js //common-marquee 為元件名稱 //marquees為跑馬燈文字資料 ex: [{text:23213},{text:456789},{text:789789}] <common-marquee :content="marquees" :speed="100">      <span v-for="(item, index) in marquees" :key="index" style="margin-right:30px;">         {{item.text}}     </span> </common-marquee> ```  ## 後續  雖然跑馬燈的功能是蠻簡單的，但是透過閱讀別人源碼學習到了蠻多以前沒注意到的觀念。'}]}}]);