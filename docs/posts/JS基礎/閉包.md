---
title: 閉包
tags: [javascript, JS基礎]
---

## 閉包
函數在可訪問的作用域之外的地方被調用就會形成閉包。  

用一個貼近生活的例子來說明閉包：  

```js

function school(){
    let schoolmaster = '陳校長'
    
    return function  securityGuard(){
        function lier(){
            schoolmaster = '許校長'
        }

        function info(){
            console.log(schoolmaster)
        }

        return {
            lier,
            info
        }
    }
}
let getSecurityGuard1 = school()
getSecurityGuard1().lier()
getSecurityGuard1().info()

let getSecurityGuard2 = school()
getSecurityGuard2().info()

```
到了一個完全沒去過的學校，不曉得校長叫什麼名字，所幸校園裡有提供一個方法讓我們找保全去詢問。  
第一個保全說叫許校長，第二個保全說叫陳校長，當然在現實中我們肯定知道有人在說謊，也還是不曉得校長到底叫什麼...  

不過依照上面的經歷中，我們已經體驗了閉包。我們始終無法真正的訪問到 `schoolmaster`確定校長真正的名字，但是我們擁有訪問它以及修改該值的能力。  
這也就是我們一開始所說的函數在可訪問的作用域之外的地方被調用就會形成閉包。

## 閉包的原理
暸解作用域與執行上下文，我們很容易理解閉包是怎麼生成的。  
函數創建時，作用域就已經確認了。而當我們執行一個函數時，執行上下文會被創建，確認了 `this`、作用域鏈、詞法環境並且推入執行棧。  

依照上面的例子，我們創建一個變數 `getSecurityGuard1`，將調用 `school` 返回的 `securityGuard` 函數賦值給 `getSecurityGuard1`，此時 `getSecurityGuard1` 可以調用 `securityGuard` 函數。  
此時的執行上下文與執行棧的變化為:  
1. 創建全局上下文，並且將全局上下文推入棧。  
2. 執行 `school`時，創建其上下文，並且推入棧。  
3. 返回 `securityGuard` 函數，`school` 出棧。  
4. 將 `securityGuard` 函數賦值給 `getSecurityGuard1` 。  

接著在全局作用域底下調用 `getSecurityGuard1` 函數，函數中又返回 `lier`、`info` 方法，接著依序執行`lier`、`info`。
1. 創建 `securityGuard` 執行上下文，並且推入棧。
2. 將  `securityGuard` 推出棧，並返回 `lier`、`info` 方法。  
3. 創建 `lier` 執行上下文，並且推入棧。
4. 修改 `schoolmaster` 的值，不過該值並沒有在 `lier` 作用域中，所以必須往上查找作用域鏈，到`school` 層的時候發現 `schoolmaster` 值，將值變為 `許校長`。  
5. `info` 與 `lier` 邏輯大致相同就不說明了。  


## 閉包的用處


## 記憶體洩漏